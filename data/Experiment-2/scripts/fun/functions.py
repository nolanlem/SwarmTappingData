import numpy as npimport librosa import matplotlib.pyplot as pltimport osfrom scipy.interpolate import interp1dimport reimport pandas as pddef t2s(a):    return librosa.time_to_samples(a)def s2t(a):    return librosa.samples_to_time(a)def per2bpm(per):    return np.round(60./(per),1)def Hz2bpm(hz):    return np.round(60.*hz, 2)def mapZCs2Circle(zcs, bwindows):    # this function maps zero crossings/taps to circle map     pooledzcs = []    for osc in zcs:        binnedzcs = binBeats(osc, bwindows)        cmapzcs = []        for i in range(1, len(binnedzcs[:19])):                    zctobin = binnedzcs[i-1]            binmin = bwindows[i-1]            binmax = bwindows[i]            bininterp = interp1d([binmin, binmax], [-np.pi, np.pi]) #map tap values within window from 0-2pi            cmapzcs.append(list(bininterp(zctobin)))        flatzcs = list(chain.from_iterable(cmapzcs))         pooledzcs.extend(flatzcs)    return np.array(pooledzcs)def binBeats(taps, beat_bins, selectoptimal = False):    taps = np.array(taps)    digitized = np.digitize(taps, beat_bins) # in secs, returns which beat bin each tap should go into    bins = [taps[digitized == i] for i in range(1, len(beat_bins) +1)]    bins = [elem if elem.size >=1 else np.nan for elem in bins]    return binsdef binTapsFromBeatWindow(taps):    binnedtaps = []    for i, tap in enumerate(taps):        try:            binnedtaps.append(taps[i][0]) # ta        except IndexError:            binnedtaps.append(np.nan)    return binnedtapsdef mapTaps2Circle(bb, bwindows):    cmaptaps = []    for i in range(1, len(bwindows)):        taptobin = bb[i-1]        binmin = bwindows[i-1]        binmax = bwindows[i]        bininterp = interp1d([binmin, binmax], [-np.pi, np.pi]) #map tap values within window from 0-2pi        cmaptaps.append(float(bininterp(taptobin)))     return cmaptapsdef mapZCs2Circle(zcs, bwindows):    pooledzcs = []    for osc in zcs:        binnedzcs = binBeats(osc, bwindows)        cmapzcs = []        for i in range(1, len(binnedzcs[:19])):                    zctobin = binnedzcs[i-1]            binmin = bwindows[i-1]            binmax = bwindows[i]            bininterp = interp1d([binmin, binmax], [-np.pi, np.pi]) #map tap values within window from 0-2pi            cmapzcs.append(list(bininterp(zctobin)))        flatzcs = list(chain.from_iterable(cmapzcs))         pooledzcs.extend(flatzcs)    return np.array(pooledzcs)def getCircMeanVector(mappedtaps):    mappedtaps = np.array(mappedtaps)    R = np.abs(np.nanmean(np.exp(1j*mappedtaps)))    psi = np.angle(np.nanmean(np.exp(1j*mappedtaps)))    return R, psidef getnPVI(itis):    nPVI = []    for n in range(1, len(itis)):        iti_diff = itis[n] - itis[n-1]        iti_diff = np.abs(iti_diff/(itis[n] + itis[n-1])/2)        nPVI.append(iti_diff)    nPVI = np.array(nPVI)/(len(itis)-1)    nPVI = 100*np.nansum(nPVI)    return nPVI    def reformatStim(thestim):    thestim = thestim.split('_')    newstimname = thestim[0] + '_' + thestim[-2] + '_' + thestim[-1]     return newstimnamedef createTapCategories(df, rootdir, saveplot=True):    theloyalists, theconverts, noneconverts = [], [], []    fig = plt.figure(figsize=(15,15))    xrange = np.arange(4)    width = 0.35    numsubjects = len(list(set(df['subject'].values)))        for i, person in enumerate(list(set(df.subject))):        couplinglisttmp = []               print(f'{person}')        cpgrp = []        for cp in ['none', 'weak', 'medium', 'strong']:            for n in [0, 1, 2, 3, 4]:                subset = df[(df['subject'] == person) & (df['coupling'] == cp) & (df['k group'] == n)]                numpercp = subset.shape[0]                #print(f' {cp} group {n} = {numpercp} ')                cpgrp.append(numpercp)                # this is hacky but grp none: group 0,1,2,3, weak: 0,1,2,3, etc.        n0, n1, nc, n3, n4, w0, w1, wc, w3, w4, m0, m1, mc, m3, m4, s0, s1, sc, s3, s4 = list(cpgrp) # unzip        # loyalists are group 0 and group 1 combined        # nc, wc, mc, sc are converters         nl = n0+n1        wl = w0+w1        ml = m0+m1        sl = s0+s1                n34 = n3 + n4        w34 = w3 + w4        m34 = m3 + m4        s34 = s3 + s4        #breakpoint()                ax = fig.add_subplot(8,7,i+1)        ax.bar(np.linspace(0,3,4), [nl, wl, ml, sl], width=2*width/3, label='loyalists')        ax.bar(np.linspace(0.3,3.3,4), [nc, wc, mc, sc], width=2*width/3, label='converters')        ax.bar(np.linspace(0.6, 3.6, 4), [n34, w34, m34, s34], width=2*width/3, label='neither')                ax.set_xticks(xrange)        ax.set_xticklabels(['n', 'w', 'm', 's'])        ax.set_title(person.split('.')[-2])        ax.set_ylim([0,10])        # save who are converters         # e.g. (num stim that they converted to was > nums stims they stayed loyal        # for none, weak, medium coupling cond)        if nc > nl:            if wc > wl and mc >= ml:                theconverts.append(person)            if wc < wl or mc < ml:                noneconverts.append(person)        else:            theloyalists.append(person)                ax = fig.add_subplot(8,7,i+2)    ax.bar([0],[0], label='loyalists')    ax.bar([0],[0], label='converter')    ax.bar([0],[0], label='neither')        ax.legend()    plt.tight_layout()        print('\n')    print(f'in total there were {len(theloyalists)} / {numsubjects} subjects who stayed loyal the whole time for each coupling cond')    print(f'in total there were {len(theconverts)} / {numsubjects} subjects who converted more than staying loyal for none, weak, and medium coupling condition')       print(f'in total there were {len(noneconverts)} / {numsubjects} subjects who converted only on the none coupling cond')           if saveplot == True:        plt.savefig(os.path.join(rootdir, 'loyalist, converts, noneconverts bar plot.png'), dpi=150)          return theloyalists, noneconverts, theconverts## NB: only use this if getting phases from original location # phase info in 'all-stims-zcs' has already been corrected (10 seconds taken out to sync with stim)def getTrigs(trigfile):    zcs = np.load(trigfile, allow_pickle=True)    zcs = [s2t(elem)-10 for elem in zcs]    zcs = [elem[elem>0] for elem in zcs]    return zcsdef binTapsFromBeatWindowGen(taps):    binnedtaps = []    avg_taps_per_bin = []    for i, tap in enumerate(taps):        try:            num_taps_in_bin = len(taps[i])            avg_taps_per_bin.append(num_taps_in_bin)            if num_taps_in_bin > 1:                   random_tap = np.random.randint(low=0, high=num_taps_in_bin)                binnedtaps.append(taps[i][random_tap]) # take random tap in window if multiple in one window            if num_taps_in_bin == 0:                binnedtaps.append(np.nan)            if num_taps_in_bin == 1:                binnedtaps.append(taps[i][0])        except IndexError:            binnedtaps.append(np.nan)        avg_taps_per_stim = np.mean(avg_taps_per_bin)    return binnedtaps, avg_taps_per_stimdef binTapsFromBeatWindowSubj(taps):    binnedtaps = []    avg_taps_per_bin = []    for i, tap in enumerate(taps):        try:            if tap.size == 0: # if no tap in bin, fill with np.nan                binnedtaps.append(np.nan)            else:                binnedtaps.append(tap)            num_taps_in_bin = len(taps[i])            avg_taps_per_bin.append(num_taps_in_bin)            # if num_taps_in_bin > 0: # this also puts in tap if size == 1 since random funct below will output 0 if range is low=0,high=1               #     random_tap = np.random.randint(low=0, high=num_taps_in_bin)            #     binnedtaps.append(taps[i][random_tap]) # take random tap in window        except IndexError:                        binnedtaps.append(np.nan)        avg_taps_per_stim = np.mean(avg_taps_per_bin)              return np.array(binnedtaps), avg_taps_per_stimdef atof(text):    try:        retval = float(text)    except ValueError:        retval = text    return retvaldef natural_keys(text):    '''    alist.sort(key=natural_keys) sorts in human order    http://nedbatchelder.com/blog/200712/human_sorting.html    (See Toothy's implementation in the comments)    float regex comes from https://stackoverflow.com/a/12643073/190597    '''    return [ atof(c) for c in re.split(r'[+-]?([0-9]+(?:[.][0-9]*)?|[.][0-9]+)', text) ]def impute_mean(thedf, rowname):    median_col_name = rowname + ' median'    themx=thedf.groupby('subject')[[rowname]].median().reset_index().rename(columns={rowname: median_col_name})    for index, row in thedf.iterrows():        if pd.isnull(row[rowname]):            #print(row[rowname])            thedf[rowname][index] = themx[median_col_name][themx['subject'] == row['subject']]            #StatewiseTestingDetails['Positive'][index]=int(stateMedianData['Median'][stateMedianData['State']==row['State']])#%% my functions         # if row[rowname] == 0:        #     thedf[rowname][index] = themx[median_col_name][themx['subject'] == row['subject']]                return thedf## get numbers of loyaists, converters, noneconverts per dfdef getNumberSubjectsPerCat(thedf):    allsubjects = sorted(set(thedf.subject))    list_subcat = []    for subject in allsubjects:        subjecttype = sorted(set(thedf[(thedf.subject == subject)]['subject cat']))        list_subcat.extend(subjecttype)    numsincat = {i:list_subcat.count(i) for i in list_subcat}    return numsincat#############def rose_plot(ax, angles, bins=16, density=None, offset=0, lab_unit="degrees",              start_zero=False, **param_dict):    """    Plot polar histogram of angles on ax. ax must have been created using    subplot_kw=dict(projection='polar'). Angles are expected in radians.    """    # Wrap angles to [-pi, pi)    angles = (angles + np.pi) % (2*np.pi) - np.pi    # Set bins symetrically around zero    if start_zero:        # To have a bin edge at zero use an even number of bins        if bins % 2:            bins += 1        bins = np.linspace(-np.pi, np.pi, num=bins+1)    # Bin data and record counts    count, bin = np.histogram(angles, bins=bins)    # Compute width of each bin    widths = np.diff(bin)    # By default plot density (frequency potentially misleading)    if density is None or density is True:        # Area to assign each bin        area = count / angles.size        # Calculate corresponding bin radius        radius = (area / np.pi)**.5    else:        radius = count    # Plot data on ax    ax.bar(bin[:-1], radius*np.pi, zorder=1, align='edge', width=widths,           edgecolor='C0', fill=False, linewidth=1)    # Set the direction of the zero angle    ax.set_theta_offset(offset)    # Remove ylabels, they are mostly obstructive and not informative    ax.set_yticks([])    if lab_unit == "radians":        label = ['$0$', r'$\pi/4$', r'$\pi/2$', r'$3\pi/4$',                  r'$\pi$', r'$5\pi/4$', r'$3\pi/2$', r'$7\pi/4$']        ax.set_xticklabels(label)